// shaders/compute/fog.wgsl
// Fog Compute Shader - applies distance fog with atmospheric scattering

struct Uniforms {
    view: mat4x4<f32>,
    inv_view: mat4x4<f32>,
    proj: mat4x4<f32>,
    inv_proj: mat4x4<f32>,
    view_proj: mat4x4<f32>,
    inv_view_proj: mat4x4<f32>,
    lighting_view_proj: array<mat4x4<f32>, 4>,
    cascade_splits: vec4<f32>,

    sun_direction: vec3<f32>,
    time: f32,

    camera_pos: vec3<f32>,
    orbit_radius: f32,

    moon_direction: vec3<f32>,
    shadow_cascade_index: u32,
};

struct FogUniforms {
    screen_size: vec2<f32>,
    proj_params: vec2<f32>,      // (near, far)

    fog_density: f32,
    fog_height: f32,
    cam_height: f32,
    _pad0: f32,

    fog_color: vec3<f32>,
    _pad1: f32,

    fog_sky_factor: f32,
    fog_height_falloff: f32,
    fog_start: f32,
    fog_end: f32,
};

// ----------------------------------------------------------------------------
// Input Textures (group 0)
// ----------------------------------------------------------------------------
@group(0) @binding(0) var hdr_input: texture_2d<f32>;      // HDR color with AO
@group(0) @binding(1) var depth_input: texture_2d<f32>;    // Linear depth (view-space Z)
@group(0) @binding(2) var tex_sampler: sampler;            // (auto-generated by compute system)

// ----------------------------------------------------------------------------
// Output Texture (group 1)
// ----------------------------------------------------------------------------
@group(1) @binding(0) var hdr_output: texture_storage_2d<rgba16float, write>;

// ----------------------------------------------------------------------------
// Uniforms (group 2)
// ----------------------------------------------------------------------------
@group(2) @binding(0) var<uniform> uniforms: Uniforms;
@group(2) @binding(1) var<uniform> fog: FogUniforms;

// ----------------------------------------------------------------------------
// Helpers
// ----------------------------------------------------------------------------
fn saturate(x: f32) -> f32 {
    return clamp(x, 0.0, 1.0);
}

// Distance fog factor (0 = no fog, 1 = full fog)
fn distance_fog_factor(view_dist: f32) -> f32 {
    return saturate(
        (view_dist - fog.fog_start) /
        max(0.001, fog.fog_end - fog.fog_start)
    );
}

// Atmospheric scattering approximation
fn scattering_color(ray_dir: vec3<f32>) -> vec3<f32> {
    // Horizon boost
    let horizon = saturate(1.0 - abs(ray_dir.y));

    // Sun forward scatter (Mie-like)
    let sun_dot = saturate(dot(ray_dir, normalize(uniforms.sun_direction)));
    let sun_scatter = pow(sun_dot, 8.0);

    let sky_tint = fog.fog_color;
    let sun_tint = vec3<f32>(1.0, 0.95, 0.85);

    return sky_tint
        + horizon * 0.25 * sky_tint
        + sun_scatter * 0.35 * sun_tint;
}

// Calculate view ray direction for a pixel
fn get_ray_dir(pixel_xy: vec2<f32>) -> vec3<f32> {
    let screen_size = vec2<f32>(textureDimensions(hdr_output));
    let uv = pixel_xy / screen_size;
    let ndc_xy = vec2<f32>(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);

    // Unproject to far plane
    let far_h = uniforms.inv_view_proj * vec4<f32>(ndc_xy, 1.0, 1.0);
    let far_pos = far_h.xyz / far_h.w;

    return normalize(far_pos - uniforms.camera_pos);
}

// ----------------------------------------------------------------------------
// Main
// ----------------------------------------------------------------------------
@compute @workgroup_size(8, 8)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
    let coords = vec2<i32>(gid.xy);
    let dims = vec2<i32>(textureDimensions(hdr_output));

    // Bounds check
    if (coords.x >= dims.x || coords.y >= dims.y) {
        return;
    }

    // Load inputs
    let hdr_color = textureLoad(hdr_input, coords, 0);
    let linear_depth = textureLoad(depth_input, coords, 0).r;

    // Calculate ray direction for atmospheric scattering
    let pixel_xy = vec2<f32>(gid.xy) + 0.5;
    let ray_dir = get_ray_dir(pixel_xy);

    // Detect sky: linear depth at or beyond far plane
    // (Adjust threshold based on your linearization; typically near far plane value)
    let far_plane = fog.proj_params.y;
    let is_sky = linear_depth >= far_plane * 0.999;

    var fog_amt: f32;
    var fog_col: vec3<f32>;

    if (is_sky) {
        // Sky fog: apply horizon-based atmospheric effect
        let horizon = saturate(1.0 - abs(ray_dir.y));
        fog_amt = horizon * fog.fog_sky_factor;
        fog_col = scattering_color(ray_dir);
    } else {
        // Geometry fog: distance-based
        // linear_depth IS the view-space distance, so use it directly
        fog_amt = distance_fog_factor(linear_depth) * fog.fog_density;
        fog_col = scattering_color(ray_dir);
    }

    // Blend: lerp from scene color toward fog color
    let final_color = mix(hdr_color.rgb, fog_col, fog_amt);

    textureStore(hdr_output, coords, vec4<f32>(final_color, hdr_color.a));
}
